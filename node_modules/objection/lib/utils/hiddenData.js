'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _create = require('babel-runtime/core-js/object/create');

var _create2 = _interopRequireDefault(_create);

var _defineProperty = require('babel-runtime/core-js/object/define-property');

var _defineProperty2 = _interopRequireDefault(_defineProperty);

exports.init = init;
exports.createGetter = createGetter;
exports.createSetter = createSetter;
exports.inheritHiddenData = inheritHiddenData;
exports.copyHiddenData = copyHiddenData;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var HIDDEN_DATA = '$$hiddenData';

function init(obj, data) {
  (0, _defineProperty2.default)(obj, HIDDEN_DATA, {
    enumerable: false,
    writable: true,
    value: data || (0, _create2.default)(null)
  });
}

function createGetter(propName) {
  var factory = new Function('\n    return function hiddenData$get' + capitalize(propName) + '(obj) {\n      if (obj.hasOwnProperty("' + HIDDEN_DATA + '")) {\n        return obj.' + HIDDEN_DATA + '.' + propName + ';\n      } else {\n        return undefined;\n      }\n    }\n  ');

  return factory();
}

function createSetter(propName) {
  var factory = new Function('\n    return function hiddenData$set' + capitalize(propName) + '(obj, data) {\n      if (!obj.hasOwnProperty("' + HIDDEN_DATA + '")) {\n        Object.defineProperty(obj, "' + HIDDEN_DATA + '", {\n          enumerable: false,\n          writable: true,\n          value: Object.create(null)\n        });\n      }\n\n      obj.' + HIDDEN_DATA + '.' + propName + ' = data;\n    }\n  ');

  return factory();
}

function inheritHiddenData(src, dst) {
  init(dst, (0, _create2.default)(src[HIDDEN_DATA] || null));
}

function copyHiddenData(src, dst) {
  init(dst, src[HIDDEN_DATA]);
}

function capitalize(str) {
  return str.charAt(0).toUpperCase() + str.substring(1);
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImhpZGRlbkRhdGEuanMiXSwibmFtZXMiOlsiaW5pdCIsImNyZWF0ZUdldHRlciIsImNyZWF0ZVNldHRlciIsImluaGVyaXRIaWRkZW5EYXRhIiwiY29weUhpZGRlbkRhdGEiLCJISURERU5fREFUQSIsIm9iaiIsImRhdGEiLCJlbnVtZXJhYmxlIiwid3JpdGFibGUiLCJ2YWx1ZSIsInByb3BOYW1lIiwiZmFjdG9yeSIsIkZ1bmN0aW9uIiwiY2FwaXRhbGl6ZSIsInNyYyIsImRzdCIsInN0ciIsImNoYXJBdCIsInRvVXBwZXJDYXNlIiwic3Vic3RyaW5nIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7OztRQUVnQkEsSSxHQUFBQSxJO1FBUUFDLFksR0FBQUEsWTtRQWNBQyxZLEdBQUFBLFk7UUFrQkFDLGlCLEdBQUFBLGlCO1FBSUFDLGMsR0FBQUEsYzs7OztBQTlDaEIsSUFBTUMsY0FBYyxjQUFwQjs7QUFFTyxTQUFTTCxJQUFULENBQWNNLEdBQWQsRUFBbUJDLElBQW5CLEVBQXlCO0FBQzlCLGdDQUFzQkQsR0FBdEIsRUFBMkJELFdBQTNCLEVBQXdDO0FBQ3RDRyxnQkFBWSxLQUQwQjtBQUV0Q0MsY0FBVSxJQUY0QjtBQUd0Q0MsV0FBT0gsUUFBUSxzQkFBYyxJQUFkO0FBSHVCLEdBQXhDO0FBS0Q7O0FBRU0sU0FBU04sWUFBVCxDQUFzQlUsUUFBdEIsRUFBZ0M7QUFDckMsTUFBTUMsVUFBVSxJQUFJQyxRQUFKLDBDQUNrQkMsV0FBV0gsUUFBWCxDQURsQiwrQ0FFY04sV0FGZCxrQ0FHR0EsV0FISCxTQUdrQk0sUUFIbEIsc0VBQWhCOztBQVVBLFNBQU9DLFNBQVA7QUFDRDs7QUFFTSxTQUFTVixZQUFULENBQXNCUyxRQUF0QixFQUFnQztBQUNyQyxNQUFNQyxVQUFVLElBQUlDLFFBQUosMENBQ2tCQyxXQUFXSCxRQUFYLENBRGxCLHNEQUVlTixXQUZmLG1EQUdvQkEsV0FIcEIsK0lBVU5BLFdBVk0sU0FVU00sUUFWVCx5QkFBaEI7O0FBY0EsU0FBT0MsU0FBUDtBQUNEOztBQUVNLFNBQVNULGlCQUFULENBQTJCWSxHQUEzQixFQUFnQ0MsR0FBaEMsRUFBcUM7QUFDMUNoQixPQUFLZ0IsR0FBTCxFQUFVLHNCQUFjRCxJQUFJVixXQUFKLEtBQW9CLElBQWxDLENBQVY7QUFDRDs7QUFFTSxTQUFTRCxjQUFULENBQXdCVyxHQUF4QixFQUE2QkMsR0FBN0IsRUFBa0M7QUFDdkNoQixPQUFLZ0IsR0FBTCxFQUFVRCxJQUFJVixXQUFKLENBQVY7QUFDRDs7QUFFRCxTQUFTUyxVQUFULENBQW9CRyxHQUFwQixFQUF5QjtBQUN2QixTQUFPQSxJQUFJQyxNQUFKLENBQVcsQ0FBWCxFQUFjQyxXQUFkLEtBQThCRixJQUFJRyxTQUFKLENBQWMsQ0FBZCxDQUFyQztBQUNEIiwiZmlsZSI6ImhpZGRlbkRhdGEuanMiLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBISURERU5fREFUQSA9ICckJGhpZGRlbkRhdGEnO1xuXG5leHBvcnQgZnVuY3Rpb24gaW5pdChvYmosIGRhdGEpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwgSElEREVOX0RBVEEsIHtcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICB2YWx1ZTogZGF0YSB8fCBPYmplY3QuY3JlYXRlKG51bGwpXG4gIH0pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlR2V0dGVyKHByb3BOYW1lKSB7XG4gIGNvbnN0IGZhY3RvcnkgPSBuZXcgRnVuY3Rpb24oYFxuICAgIHJldHVybiBmdW5jdGlvbiBoaWRkZW5EYXRhJGdldCR7Y2FwaXRhbGl6ZShwcm9wTmFtZSl9KG9iaikge1xuICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShcIiR7SElEREVOX0RBVEF9XCIpKSB7XG4gICAgICAgIHJldHVybiBvYmouJHtISURERU5fREFUQX0uJHtwcm9wTmFtZX07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgIH1cbiAgYCk7XG5cbiAgcmV0dXJuIGZhY3RvcnkoKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVNldHRlcihwcm9wTmFtZSkge1xuICBjb25zdCBmYWN0b3J5ID0gbmV3IEZ1bmN0aW9uKGBcbiAgICByZXR1cm4gZnVuY3Rpb24gaGlkZGVuRGF0YSRzZXQke2NhcGl0YWxpemUocHJvcE5hbWUpfShvYmosIGRhdGEpIHtcbiAgICAgIGlmICghb2JqLmhhc093blByb3BlcnR5KFwiJHtISURERU5fREFUQX1cIikpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwgXCIke0hJRERFTl9EQVRBfVwiLCB7XG4gICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgdmFsdWU6IE9iamVjdC5jcmVhdGUobnVsbClcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIG9iai4ke0hJRERFTl9EQVRBfS4ke3Byb3BOYW1lfSA9IGRhdGE7XG4gICAgfVxuICBgKTtcblxuICByZXR1cm4gZmFjdG9yeSgpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaW5oZXJpdEhpZGRlbkRhdGEoc3JjLCBkc3QpIHtcbiAgaW5pdChkc3QsIE9iamVjdC5jcmVhdGUoc3JjW0hJRERFTl9EQVRBXSB8fCBudWxsKSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjb3B5SGlkZGVuRGF0YShzcmMsIGRzdCkge1xuICBpbml0KGRzdCwgc3JjW0hJRERFTl9EQVRBXSk7XG59XG5cbmZ1bmN0aW9uIGNhcGl0YWxpemUoc3RyKSB7XG4gIHJldHVybiBzdHIuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBzdHIuc3Vic3RyaW5nKDEpXG59Il19